## 1. PORTFOLIO PROJECT
It's a portfolio application with 2 backend microservices. One for fetching user data and one for fetching user projects. The frontend has been developed using React and the backend with NodeJS.
![image](https://github.com/mohamedbenattia99/devops-gl5-lab/blob/main/screenshots/1.png)
### Infrastructure Tools 
For the implementation of the infrastructure the following tools were used.
#### IaC tools
 - Kubernetes
 - Kustomize
 - Terraform
 - Helm
#### Monitoring tools
 - Grafana and Datadog for Visualization.
 - Prometheus, to pull metrics.
## 2. Observability
### 1. Logging
I used the library winston on Nodejs to enable logging
These are the logs generated by app. We added a unique Request_id and the Client IP Address to the logs for a better analysis of the logs.
![image](https://github.com/mohamedbenattia99/devops-gl5-lab/blob/main/screenshots/4.png)

### 2. Metrics
We used the library prom-client to configure metrics in the application.
This is a custom metrics that we created.
![image](https://github.com/mohamedbenattia99/devops-gl5-lab/blob/main/screenshots/6.png)
Those metrics are pulled by our prom-client to prometheus.
![image](https://github.com/mohamedbenattia99/devops-gl5-lab/blob/main/screenshots/2.png)
We visualized our cluster metrics using grafana.
![image](https://github.com/mohamedbenattia99/devops-gl5-lab/blob/main/screenshots/3.png)

## 3. Automation
For the automation we used 2 stacks in terraform. 

### 1. Kubernetes Cluster provisioning
Here we created a resource group for the cluster and provisioned an AKS cluster. 
We also configured Terraform to use Azure Blob Storage as remote state backend.

 
### 2. Monitoring automation
We created the monitoring setup for our application using Kubernetes provider as well as Helm provider. We used the kube-prometheus-stack helm chart to install proetheus and grafana. 

## 3. Deployment
This is the architecture of the deployment of the application.

![architecture](https://github.com/mohamedbenattia99/devops-gl5-lab/blob/main/screenshots/5.png)
 
We used the blue/green deployment strategy because we want to maintain two identical production environments. In this case, the blue deployment has a label "V1.0.0" and the green has a label of "V2.0.0". During the update we wanted the new version deployed and tested on a production environment and redirecting the user traffic after it has been verified.


# Setting up the cluster
To set-up the cluster we used a micro-stack architecture using Terraform.
## Cluster provisioning
The cluster micro-stack will provision the AKS cluster with a node pool of two nodes. It will output the kube-config for the other stack to use.
```
terraform init
terraform plan
terraform apply
```
